2019-04-29
매번 짤방을 손으로 저장하다가, 프로그램의 필요성을 느꼈다.
예전에 잠깐 만져봤던 node.js를 써보기로 했다.
요즘은 자바스크립트로도 텔레그램 봇을 만들기가 쉽다고 한다.

덕분에 node.js를 다시 공부했다.
node.js 자체는 그리 내용이 많지 않다.
단지 거기에 붙여야 할 수많은 모듈들을 앞으로 공부해야 할 것이다.


2019-04-30
파싱 라이브러리로 jssoup를 써보기로 했다.
예전에 파이썬 크롤링을 하면서 beautiful soup를 편하게 썼던 기억이 난다.
jssoup는 beautiful soup의 광팬이 자바스크립트로 그 라이브러리를 포팅한 것이라 한다.

jssoup를 설치했는데도 node.js가 모듈을 못찾아서 말썽을 부렸다.
검색을 해봤더니, 가급적이면 모듈은 프로젝트 로컬 경로에 설치하라고 한다.
글로벌하게 설치하고, 어찌어찌 우회를 해서 사용할 수도 있지만 바람직하지는 않다고 한다.

오늘은 트윗에서 사용자가 올린 이미지의 URL을 추출하고, 그 URL로부터
파일을 받아 저장하는 것을 완성했다. 그리 어렵지는 않았다.

이제 다양한 사이트로부터 이미지 추출하는 finder만 만들고
텔레그램 봇 API를 공부해서 연결하면 되겠다.



2019-05-01
오늘은 pixiv에서 이미지 추출하는 것을 시도했다.
매우 험난한 여정이었다.

우선 jssoup가 말썽을 일으켰다. pixiv 페이지의 이미지 DOM들은 class 이름에
공백이 들어가 있었다. 그런데 jssoup는 이 공백을 정상적으로 처리하지 못했다.
하는 수 없이 다른 라이브러리를 알아보다, cheerio.js라는 대중적인 파서 라이브러리를
찾았다.

cheerio.js는 jquery와 비슷한 인터페이스를 가지되 좀 더 확장성을 가지도록 만들어진
모듈로, jquery 공화국인 대한민국에서도 널리 알려진 모듈이었다.
그런데 나는 jquery를 한 번도 써 본 적이 없었다. (그 특유의 $가 너무 싫다)
항상 명시적으로 개체를 찾은 뒤 명령하는 것에 익숙해진 나는, jquery 특유의 이상한
인터페이스가 너무 마음에 들지 않았다.

게다가 cheerio.js는 자체 문서화가 거의 이루어지지 않았다.
그냥 jquery처럼 쓰시면 돼요~라고만 적어놨고... 
나는 할 수 없이 울며 겨자먹기로 jquery 기초를 익힐 수 밖에 없었다.

두 번째 문제는 pixiv 페이지 자체에 있었다.
봇들이 크롤링하는 것을 막기 위함인지, 이미지를 동적으로 로딩하고 있었다.
단순히 한 번 요청한 것만으로는 도저히 이미지 주소를 알아낼 방법이 없었다.

동적인 것이 문제라면 safebooru 태그 수집할 때 썼던 selenium을 쓰면 될 거 같긴 했다.
그러나 selenium 자체가 너무나 무겁고 지저분한데다 실행 속도도 너무 느려서
다른 방법을 찾아보기로 했다. (하지만 그냥 selenium 쓸 걸 그랬다....)

페이지 분석할 때 추측한 바로는, 내가 로그인을 한 상태로 pixiv에서 자료를 요청하면
pixiv에서 json 형태로 여러가지 정보를 클라이언트에 보낸다.
클라이언트는 이 json 파일을 토대로 브라우저에 이미지를 동적으로 띄우는 것.
그래서 처음부터 이미지가 뜨지 않았던 것이었다.

하지만 이걸 모두 구현하기에는 시간이 너무 오래 걸렸다.
친구가 API 한 번 찾아보는게 어떻겠냐고 제안해서 구글링을 했고, 다행히 바퀴를
발명할 일은 없게 되었다.

akameco라는 고마운 개발자가 pixiv-app-api라는 갓갓 모듈을 개발했다.
이걸 사용하니 큰 고민 없이 pixiv로부터 정보를 긁어올 수 있었다.
pixiv에서는 이미지가 저장된 URL에 직접 접근을 못하도록 막아뒀는데,
이것마저 뚫어버리는 pixiv-img라는 모듈도 같이 배포하고 있다.
(원리 자체는 간단할 것이다. 정상적으로 브라우저에 로그인 한 상태에서
주고받는 데이터를 분석하고, 그걸로 헤더를 재현하여 서버로부터 받아오는 구조일 것이다)

4시간이 넘는 사투 끝에 드디어 pixiv로부터 이미지를 다운로드 받을 수 있었다.



2019-05-05
텔레그램 봇을 하나 등록했다. 이름은 IIONA(Illustration IO Network Assistant)다.
텔레그램 봇 API를 연결해서 다음의 기능까지 구현했다.

- /test로 봇이 살아있는지 확인
- 이미지를 직접 봇에게 공유한 경우 다운로드
- 트위터 URL을 공유할 경우 글쓴이의 타래에 포함된 모든 이미지를 다운로드
- 픽시브 URL을 공유할 경우 그 글에 올라온 모든 이미지를 다운로드

만드는 과정에서 몇 가지 버그와 조우했다.

- 트위터 URL을 공유할 경우, 댓글로 달린 쓸데없는 이미지도 긁어옴
→ selector를 좀 더 좁게 잡아줌으로서 댓글 div를 제외하여 해결

- 픽시브에 그림이 하나만 온라온 경우 정상적으로 다운로드 못하는 문제
→ 픽시브에 2개 이상의 그림이 올라온 경우 json.illust.metaPages.imageUrls에 탑재되고, 1개만 올라온 경우 json.illust.imageUrls에 탑재되므로 경우를 나눠서 처리

- URL 파싱 리스너를 추가한 이후로 직접 이미지 공유가 동작하지 않는 문제
→ on('message')는 다른 이벤트 리스너를 전부 덮어쓰는 병신같은 구조적 문제가 있음. 따라서 onText(URL_REGEX, callback)로 구분을 해줌



2019-06-03
주면 저장만 하는 수동적인 봇에서, 사용자와 상호작용을 하는 동적인 봇으로 바꾸기 위해 구조 수정을 계획했다.
이미지를 수집하다보면, 서로 다른 수많은 이미지가 한 폴더에 저장되었다.
그래서 이미지를 저장할 때 마다, 저장할 폴더를 지정하는 방식으로 개선하기로 했다.

이를 구현하려면 기존의 비동기 코드를 전면적으로 수정해야 한다.
적어도 내게 폴더 명을 묻기 전까지는 비동기로 마구잡이로 실행되어선 안된다.

생각없이 레거시 코드인 .on().then()을 남발하자 코드가 지저분해졌다.
고수 친구가 최신 문법인 async await을 권장하여 갈아타기로 했다.

문제는 내가 쓰던 request 모듈이 Promise가 없던 시절에 개발되어서 async await와 호환되지 않는다는 점이었다.
공식 레퍼런스를 읽고, 공식에서 추천하는 Promise 호환 래퍼를 받았으면 문제가 쉽게 해결되었을 것이다.
그러나 나는 대충 구글링에서 async request를 검색했고, async-request라는 검증되지 않은 모듈을 사용하게 되었다.

그 모듈은 멍청하게도 header와 body만을 얻을 수 있었고, 이미지를 다운로드받을 때 쓸 pipe 기능을 제공하지 않았다.
이 사실을 깨닫는데 많은 시간이 걸렸고, 급기야 깃허브 저장소에서 소스코드를 분석하기에 이르렀다.
결국 나는 async-request로 수정했던 코드를 전부 뜯어내야 했다.

이 문제를 해결하는 방법은 간단했는데, 그냥 내가 Promise를 만들면 되는 것이었다.
야매로 무언가를 하는 것은 굉장히 큰 문제를 일으킨다는 걸 알았다.